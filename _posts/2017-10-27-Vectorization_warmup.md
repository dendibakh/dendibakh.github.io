---
layout: post
title: Vectorization part2. Warmup.
categories: [vectorization]
---

------
**Subscribe to my [newsletter](https://mailchi.mp/4eb73720aafe/easyperf), support me on [Patreon](https://www.patreon.com/dendibakh) or by PayPal [donation](https://www.paypal.com/cgi-bin/webscr?cmd=_donations&business=TBM3NW8TKTT34&currency_code=USD&source=url).**

------

I want to do this warmup post, just to be sure that we are on the same page. It will also give you the taste of how the vector assembly looks like and how it works.
I remember when I was learning vectorization stuff, I really missed the assembly that was generated by the compiler. I was like: "Show me assembly, I want to see how it's done." Even if there was assembly I didn't understand how this hairy scary lines of code do the job.


I find the example in this post somewhat special. It might be not the most efficient assembly code, but in my opinion it nicely shows capabilities of the vectorization. So, in this post we will go through an assembly code line by line, visualizing the state of the registers after some portion of assembly code.

Here is the example: [godbolt](https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(j:1,source:'int+foo(+short+a%5B16%5D,+unsigned+short+b%5B16%5D,+unsigned+short+bias%5B16%5D+)%0A%7B%0A++++int+agg+%3D+0%3B%0A++++for(+int+i+%3D+0%3B+i+%3C+16%3B+i%2B%2B+)%0A++++%7B+%0A%09%09if(+a%5Bi%5D+%3E+0+)+%0A%09%09%09a%5Bi%5D+%3D+(bias%5Bi%5D+%2B+a%5Bi%5D)+*+b%5Bi%5D+%3E%3E+16%3B+%0A%09%09else+%0A%09%09%09a%5Bi%5D+%3D+-+((bias%5Bi%5D+-+a%5Bi%5D)+*+b%5Bi%5D+%3E%3E+16)%3B+%0A%09%09agg+%2B%3D+a%5Bi%5D%3B+%0A%09%7D%0A++++return+agg%3B%0A%7D'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),header:(),k:50,l:'4',m:100,n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:gsnapshot,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'1',intel:'0',trim:'0'),libs:!(),options:'-O3+-march%3Dcore-avx2',source:1),l:'5',n:'0',o:'x86-64+gcc+(trunk)+(Editor+%231,+Compiler+%231)',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4).

In general, compiler has quite hard time dealing with various control flow statements inside the loop when trying to vectorize it. Vectorization gets much harder when there is if statement inside the loop, and even infeasible when there is a break or throwing exception. However, in our example there is if statement and the loop was successfully vectorized by gcc.
```cpp
int foo( short a[16], unsigned short b[16], unsigned short bias[16] )
{
  int agg = 0;
  for( int i = 0; i < 16; i++ )
  { 
    if( a[i] > 0 ) 
      a[i] = (bias[i] + a[i]) * b[i] >> 16; 
    else 
      a[i] = - ((bias[i] - a[i]) * b[i] >> 16); 
    agg += a[i]; 
  }
  return agg;
}
```
### Loading

Let's look at first 4 instructions. Description of all instructions can be found [here](https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf).
```asm
 vmovdqu ymm4,YMMWORD PTR [rdi] # a[]
 vmovdqu ymm2,YMMWORD PTR [rdx] # bias[]
 vmovdqu ymm5,YMMWORD PTR [rsi] # b[]
 vmovdqa ymm6,YMMWORD PTR [rip+0x5c6] # 400b00
```
They load our input arrays into registers. By [x86 calling conventions](https://en.wikipedia.org/wiki/X86_calling_conventions) for 64 bit architecture our first three arguments are stored in `rdi`, `rsi` and `rdx` respectively.

Here is what values are in registers after this step (I removed registers `ymm10-ymm15` because they are not used in this example):

![](/img/posts/VectorizationWarmup/Loading.png){: .center-image }

### Extracting

Because our computations can overflow the size of short, we need to use 32 bit integers for computation. That's why we first "unpack" all the 16-bit values and make them 32-bit.

```asm
 vpmovzxwd ymm1,xmm2
 vextracti128 xmm8,ymm4,0x1
 vextracti128 xmm2,ymm2,0x1
```

`vpmovzxwd ymm1, xmm2` instruction zero extend 8 16-bit integers in `xmm2` to 8 32-bit integers and puts them into `ymm1`.
`vextracti128 xmm8,ymm4,0x1` extract 128 most significant bits (3rd parameter `0x1` tells to do so) of integer data from `ymm4` and store results in `xmm8`.

![](/img/posts/VectorizationWarmup/Extracting1.png){: .center-image }

Next stage is mostly similar to the previous one, so I will just skip it and only show the result. You can trace it by your own.

```asm
 vpmovzxwd ymm9,xmm5
 vpmovzxwd ymm2,xmm2
 vpmovsxwd ymm0,xmm4
 vpmovsxwd ymm8,xmm8
 vextracti128 xmm5,ymm5,0x1
```

![](/img/posts/VectorizationWarmup/Extracting2.png){: .center-image }

### Computation

Up to this moment we prepared all data into separate parts. Next assembly blob is actually doing computation inside the loop.

```asm
 vpaddd ymm3,ymm1,ymm0
 vpmovzxwd ymm5,xmm5
 vpsubd ymm0,ymm1,ymm0
 vpsubd ymm1,ymm2,ymm8
 vpmulld ymm0,ymm0,ymm9
 vpmulld ymm1,ymm1,ymm5
 vpaddd ymm7,ymm2,ymm8
 vpmulld ymm3,ymm3,ymm9
 vpmulld ymm7,ymm7,ymm5
```

So, `vpaddd`, `vpsubd` and `vpmuld` do arithmetic operations on dwords and I believe you can easily extract what each instruction does from its name. I will mark temporary results with the signs of completed arithmetic operations. For example, `bias[i] + a[i]` as `result of +`, `(bias[i] - a[i]) * b[i]` as `result of - *`.

Updated state of the registers looks like this:

![](/img/posts/VectorizationWarmup/Computation.png){: .center-image }

Finally, we do the right shifts.
```asm
 vpsrad ymm0,ymm0,0x10
 vpsrad ymm1,ymm1,0x10
 vpand ymm1,ymm6,ymm1
 vpsrad ymm3,ymm3,0x10
 vpand ymm0,ymm6,ymm0
```

By doing `vpand ymm1,ymm6,ymm1` we just zeroing most significant half of the bits of each value in `ymm1` (recall that `ymm6` has values `0xFFFF` in it). We need to do that because `vpsrad` is doing sign extension after shifting.

![](/img/posts/VectorizationWarmup/Shifting.png){: .center-image }

### Packing

```asm
 vpackusdw ymm0,ymm0,ymm1
 vpsrad ymm7,ymm7,0x10
 vpxor xmm1,xmm1,xmm1
```
`vpackusdw ymm0, ymm0, ymm1` converts 8 16-bit signed integers from `ymm0` and 8 16-bit signed integers from `ymm1` and store them into 16 16-bit unsigned integers in `ymm0`. 

![](/img/posts/VectorizationWarmup/Packing.png){: .center-image }

### Handling if statement

```asm
 vpcmpgtw ymm4,ymm4,ymm1
 vpand ymm3,ymm6,ymm3
 vpand ymm7,ymm6,ymm7
 vpackusdw ymm3,ymm3,ymm7
```

This is the most interesting part of this example. Instruction `vpcmpgtw ymm4,ymm4,ymm1` compares 16-bit signed integers for greater than. Effectively this instruction does all 16 comparisons just in one instruction. Amazing!
And for each pair of 16-bit ints it stores either `0xFFFF` or `0` in the destination vector, depending on the result of the comparison.

![](/img/posts/VectorizationWarmup/IfStatement.png){: .center-image }

### Writing back

Note, that at this stage we have both branches of if statement computed (in `ymm0` and `ymm3`) and we know all outcomes of the if conditions (in `ymm4`). So, we need to select proper values from correct branch results.

```asm
 vpermq ymm0,ymm0,0xd8
 vpermq ymm3,ymm3,0xd8
 vpsubw ymm0,ymm1,ymm0
 vpblendvb ymm0,ymm0,ymm3,ymm4
 vpmovsxwd ymm1,xmm0
 vmovdqu YMMWORD PTR [rdi],ymm0
```

`vperfmq ymm0,ymm3,0xd8` permute qwords in ymm3 using indexes in the third operand(`0xd8`) and store the result in ymm0. We need to permute values in `ymm0` and `ymm3` because of the nature of `vpackusdw` (see above). When `vpackusdw` combines two arrays together it does interleaving. When combining `a[0..7]` and `a[8-15]` this instruction makes the output of `a[0..3] a[8-11] a[4-7] a[12-15]`. So, to receive correct result we need to swap elements in the middle. And this is exactly what `vpermq` instruction with the mask `0xd8` is doing.

`vpsubw ymm0,ymm1,ymm0` simply negates all the values in `ymm0`, completing final steps of computation.

`vpblendvb ymm0,ymm0,ymm3,ymm4` selects values from `ymm0` and `ymm3` according to the control in `ymm4` and stores them into `ymm0`.

And finally, `vmovdqu YMMWORD PTR [rdi],ymm0` stores values from `ymm0` back to memory (in `a[]`).
What is left is calculate the return value (`agg`), bit I will leave this exercise for the reader. 

### Conclusions

I want to point out a couple of things we learned from this example.
1. Note, that the loop was fully vectorized, meaning that there are no backward jump. It is simple for compiler to do because the trip count (number of loop iterations) is known.
2. Still there is lots of scalar code. I will explain why we need it in the next posts. Stay tuned.
3. Surprisingly, gcc is not using horizontal add for calculating `agg`. Clang does, but it is only able to vectorize the loop when using [GVN-hoisting](https://www.youtube.com/watch?v=GB3OpqSwuUw) (-mllvm -enable-gvn-hoist). [link to godbolt](https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(j:1,source:%27int+foo(+short+a%5B16%5D,+unsigned+short+b%5B16%5D,+unsigned+short+bias%5B16%5D+)%0A%7B%0A++++int+agg+%3D+0%3B%0A++++for(+int+i+%3D+0%3B+i+%3C+16%3B+i%2B%2B+)%0A++++%7B+%0A%09%09if(+a%5Bi%5D+%3E+0+)+%0A%09%09%09a%5Bi%5D+%3D+(bias%5Bi%5D+%2B+a%5Bi%5D)+*+b%5Bi%5D+%3E%3E+16%3B+%0A%09%09else+%0A%09%09%09a%5Bi%5D+%3D+-+((bias%5Bi%5D+-+a%5Bi%5D)+*+b%5Bi%5D+%3E%3E+16)%3B+%0A%09%09agg+%2B%3D+a%5Bi%5D%3B+%0A%09%7D%0A++++return+agg%3B%0A%7D%27),l:%275%27,n:%270%27,o:%27C%2B%2B+source+%231%27,t:%270%27)),header:(),k:33.333333333333336,l:%274%27,m:100,n:%270%27,o:%27%27,s:0,t:%270%27),(g:!((h:compiler,i:(compiler:gsnapshot,filters:(b:%270%27,binary:%271%27,commentOnly:%270%27,demangle:%270%27,directives:%270%27,execute:%271%27,intel:%270%27,trim:%270%27),libs:!(),options:%27-O3+-march%3Dcore-avx2%27,source:1),l:%275%27,n:%270%27,o:%27x86-64+gcc+(trunk)+(Editor+%231,+Compiler+%231)%27,t:%270%27)),k:33.333333333333336,l:%274%27,n:%270%27,o:%27%27,s:0,t:%270%27),(g:!((h:compiler,i:(compiler:clang_trunk,filters:(b:%270%27,binary:%271%27,commentOnly:%270%27,demangle:%270%27,directives:%270%27,execute:%271%27,intel:%270%27,trim:%270%27),libs:!(),options:%27-O3+-march%3Dcore-avx2+-mllvm+-enable-gvn-hoist%27,source:1),l:%275%27,n:%270%27,o:%27x86-64+clang+(trunk)+(Editor+%231,+Compiler+%232)%27,t:%270%27)),k:33.33333333333333,l:%274%27,n:%270%27,o:%27%27,s:0,t:%270%27)),l:%272%27,n:%270%27,o:%27%27,t:%270%27)),version:4).
4. There is not so much register pressure in this function. Registers `ymm10-ymm15` are free for compiler to do something else. So, still there is some free space for the vectorizer to handle even more complex code.

As a final note I want to put a links to the two great presentations from CppCon2017:
1. [Matt Godbolt - “What Has My Compiler Done for Me Lately? Unbolting the Compiler's Lid”.](https://www.youtube.com/watch?v=bSkpMdDe4g4&list=PLHTh1InhhwT6bwIpRk0ZbCA0N2p1taxd6&index=5)
2. [Charles Bailey “Enough x86 Assembly to Be Dangerous”.](https://www.youtube.com/watch?v=IfUPkUAEwrk&index=34&list=PLHTh1InhhwT6bwIpRk0ZbCA0N2p1taxd6)

### All posts from this series:
1. [Vectorization intro]({{ site.url }}/blog/2017/10/24/Vectorization_part1).
2. Vectorization warmup (this article).
3. [Checking compiler vectorization report]({{ site.url }}/blog/2017/10/30/Compiler-optimization-report).
4. [Vectorization width]({{ site.url }}/blog/2017/11/02/Vectorization_width).
5. [Multiversioning by data dependency]({{ site.url }}/blog/2017/11/03/Multiversioning_by_DD).
6. [Multiversioning by trip counts]({{ site.url }}/blog/2017/11/09/Multiversioning_by_trip_counts).
7. [Tips for writing vectorizable code]({{ site.url }}/blog/2017/11/10/Tips_for_writing_vectorizable_code).
